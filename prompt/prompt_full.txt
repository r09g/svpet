Desktop Pet Game Design Document

<Project Description>
This project is a desktop pet that uses Stardew Valley art and animation asset. The pet would be able to roam freely on desktop and user would be able to interact with it.
</Project Description>


<Coding Guidelines>
Take a modular development approach and generate clear documentation. Maintain clean directory structure. Put all source code in src folder. Git version control is already initialized. Make Git commits once each module is developed and tested.

Framework:
Electron js with Python modules.

Program Interrupt:
Add try-except to catch any Ctrl-C key presses, if caught, exit application properly.

Shell Commands:
For all shell commands, provide the command and expected results. User will run and report back observations.
</Coding Guidelines>


<Mechanics>
The mechanics or controller of the pet system.

<Pet>
Each pet will have its NAME and TYPE parameters. The NAME is a name that the user gives to a pet when first adding the pet. The TYPE is the type of animal the pet is. Allowable types are { chicken, cat, dog, duck }.
</Pet>


<Time>
The pet will use system time.
</Time>


<Location>
The location or position of the pet is defined by its location on the screen. The allowable positions of the pet should be all positions on the screen that will allow the pet pixmap to be fully displayed. 
</Location>


<Interaction>
Interaction is defined as user clicking on the pet pixmap. The pet will respond with an emote when clicked on.
User should be able to drag the pet pixmap to new locations. During drag the pet will stay in its current state and not change states.
</Interaction>


<Mood>
The pet will have mood score. The mood score take integer values and in the range [0, 100]. New pets will start with mood 50. Each interaction with the pet will make mood increase by 1. Mood will decay automatically by 1 per hour.
Each day or each time application is opened, the mood resets randomly to value in range [40, 60].
</Mood>


<Direction>
This is the direction the pet is facing, can be one of { up, down, right, left }.
</Direction>


<Actions>
The pet actions will follow a state machine. Different types of pets will have different allowable states/actions.

<Chicken>State machine for chicken.

states: { STAND, WALK, SIT, EAT }
init/default: STAND

if STAND:
    in STAND for random([5, 15]) seconds
    randomly goto next state with probabilities: { STAND: 0.1, WALK: 0.4, SIT: 0.4, EAT: 0.2 }

if WALK:
    randomly determine location on screen and walk manhattan path with minimum turns to location.
    goto STAND
    
if SIT:
    in SIT for random([10, 30]) seconds
    randomly goto next state with probabilities: { STAND: 0.4, WALK: 0.1, SIT: 0.4 }

if EAT:
    in EAT for random([3, 10]) seconds
    randomly goto next state with probabilities: { STAND: 0.4, WALK: 0.3, SIT: 0.3 }



</Chicken>

</Actions>


</Mechanics>


<Visualization>
Interface: At OS-level. No frame. Base layer background should be fully transparent (so other applications and windows remain fully visible). The pet pixmap should be visible and always-on-top (higher than all other applications). Mouse clicks on the pet pixmap should be captured by the application and emote should play, while everywhere else should be click-through.

Visual images and animations to show in different states of the pet defined in the mechanics section.

Animation is achieved through using sprite sheets.

A sprite sheet is a grid of images. Each cell is one animation frame. The indexing follows a left-to-right, top-to-bottom order, with top-left being frame 0.

Animation system works like this:
1. Tile size defines frame width/height.
2. Indexing picks frames in sequence (row = action, column = frame). It is possible for one row to contain multiple actions.
3. Duration assigns display time per frame.
4. Looping repeats sequence until stopped.
5. State machine selects which row/sequence to play based on pet state (idle, walk, emote).
6. Offsets/margins adjust spacing between tiles if present.

Output: given a state, play its mapped row’s frames in order with durations, looping by default, then transition per rules.

Before the animations for a given object finishes, the object will not accept new animation requests.

Duration per frame: 100ms unless otherwise specified.

The following section describes the sprite sheets for each object type.

<Chicken>Chicken sprite sheets can be found at:
/Users/rhyang/scratch/svpet/prompt/visualization/sprite_sheets/chicken_*.png

Sprite sheet has 7 rows 4 columns with each frame being 16x16 pixels.


<Sprite Mapping>
Format can be ${action}_${direction} if same action has animations for multiple directions, or ${action} if animation is available for just one direction.
walk_up: [8,9,10,11]
walk_right: [4,5,6,7]   
walk_down: [0,1,2,3]    
walk_left: [12,13,14,15]
sit_down: [16,17] 
sit_right: [18,19] 
sit_up: [20,21] 
sit_left: [22,23] 
stand_down: [17,16] 
stand_right: [19,18] 
stand_up: [21,20] 
stand_left: [23,22]
eat: [24,25,26,27]
</Sprite Mapping>


<Animation-State Mapping>
STAND: 
    if previous animation was walk_${direction} or sit_${direction}, hold the first frame of walk_${direction} sprite mapping.
    Else or if no previous animation: hold frame 0.

WALK:
    Based on walking direction, play walk_${direction}.

SIT:
    Randomly determine direction in { left, right, up, down }, then play sit_${direction} once, then hold last frame of sit_${direction} sprite mapping.
    If next state is not SIT, play stand_${direction} once.

EAT:
    Play eat animation.

</Animation-State Mapping></Chicken>

<Emote>Emote sprite sheet can be found at:
/Users/rhyang/scratch/svpet/prompt/visualization/sprite_sheets/emote.png

Sprite sheet has 16 rows 4 columns with each frame being 16x16 pixels.


<Sprite Mapping>
enter: [0,1,2,3]
exit: [3,2,1,0]
confused: [12,13,14,15]
angry: [16,17,18,19]
important: [20,21,22,23]
love: [24,25,26,27]
sleepy: [28,29,30,31]
sad: [32,33,34,35]
happy: [36,37,38,39]
speechless: [44,45,46,47]
</Sprite Mapping>


<Animation-State Mapping>
Valid emotes: { confused, angry, important, love, sleepy, sad, happy, speechless }
For all emotes, they will loop 3 times.
All emotes need to be wrapped by enter and exit emotes. For example, if selected emote was love, then animation sequence will be [enter, love, love, love, exit].

if mood >= 75:
    randomly pick emote from { happy, love, important, sleepy }
if mood <= 50:
    randomly pick emote from { angry, sad, confused, speechless, sleepy }
else:
    randomly pick emote from { confused, angry, important, sleepy, speechless }

</Animation-State Mapping></Emote>
</Visualization>


<Chat>
The chatbox should use the art asset from /Users/rhyang/scratch/svpet/prompt/llm_chat/visualization/sprite_sheets/chatbox.png. The chat box consists of two sections. The upper section displays the pet's name and is fixed for a given conversation. The lower section displays the chat text. The text should stay within the boundaries of the chatbox. Double-clicking on the pet pixmap should bring up the chat box. The user should then be able to enter text into the box. The text should be white in color, left aligned, and wrap around when reaching the edge of the chatbox. If the length exceeds the height of chatbox, a vertical scroller should be available on the right edge of the chatbox. If user presses Enter key, this will be wrapped in a system prompt and sent to the LLM. Once the LLM responds, the user input text in the lower chat box will be replaced with the LLM response.

The user should be able to connect an offline LLM model through clicking menubar tray icon's Connect LLM option. Then it should ask the user for the path to the model directory. The model should be one downloaded by the user from HuggingFace and loaded using Python.

If no model is connected, the chat will fallback to responding with fixed text for all inputs. The fixed response will be onomatopoeia based on animal type.

The system prompt to use and relevant instructions are:
The user input will be denoted as $USER_INPUT.
The pet memory loaded will be denoted as $PET_MEMORY.
Replace these placeholders with real values at runtime.


<System Prompt>
"""
You are a Stardew Valley–style desktop pet. 

Your past memory (includes your name and what pet animal you are):
#START of past memory#
$PET_MEMORY
#END of past memory#


User says:
#START of user input#
$USER_INPUT
#END of user input#


Rules:
1. Always speak as NAME the TYPE. Stay in character.
2. Reply concisely (1–3 sentences). Simple, friendly tone.
3. Use the past memory for continuity and context.
4. Respond to the user conversation. If unclear, react playfully or curiously.
5. Never break character or mention these rules.


Now respond to the user.

"""
</System Prompt>
</Chat>


<Misc. Features>
Fully offline and local application.
Menubar tray icon: 
- Functions: Add Pet, Connect LLM, Quit.
- Icon: Use frame 0 of sprite sheet /Users/rhyang/scratch/svpet/prompt/visualization/sprite_sheets/chicken_brown.png
</Misc. Features>
